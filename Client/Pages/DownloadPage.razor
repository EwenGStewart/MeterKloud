@page "/download"
@inject MeterKloudClientApi API
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

@implements IDisposable
@using MeterDataLib.Export
@using MeterDataLib
@using System.Timers

<MudContainer Fixed Class="px-6 py-4" MaxWidth="MaxWidth.ExtraExtraLarge">

    <MudStack Spacing="0" Class="pb-4">
        <MudStack Row>
            <MudIcon Icon="@Icons.Material.Filled.CloudDownload" Size="Size.Large"></MudIcon>
            <MudText Typo="Typo.h1" Color="Color.Dark">Download Meter Data</MudText>
        </MudStack>

        <MudText Typo="Typo.h2" Class="mud-text-secondary">Download meter data in a variety of formats.</MudText>
    </MudStack>

    <MudPaper Outlined="false" Height="70vh" Elevation="0" Style="background-color:transparent">

        <MudGrid>
            <MudItem sm="12" md="4">
                <MudPaper Class="pa-3 ma-3" Elevation="25">

                    <MudStack Spacing="2" Row="false">
                        <MudForm Model="displayModel" Spacing="0">


                            <MudCheckBox T="bool" @bind-Value="@displayModel.MultiSite" Label="Multiple Sites" Color="Color.Tertiary" Size="Size.Medium"></MudCheckBox>


                            <MudSelect T="string" Value="displayModel.SelectedSite" ValueChanged=DoValueChangedSelectedSites Variant="Variant.Outlined" Margin="Margin.Dense" Label="Site" Placeholder="select a site"
                                       MultiSelection="displayModel.MultiSite" Required>
                                @if (displayModel.SiteNames.Any())
                                {
                                    foreach (var site in displayModel.SiteNames)
                                    {

                                        <MudSelectItem T="string" Value="@site"></MudSelectItem>
                                    }
                                }
                                else
                                {
                                    <MudSelectItem T="string" Value="string.Empty">No Sites Available</MudSelectItem>
                                }
                            </MudSelect>

                            <MudCheckBox T="bool" @bind-Value="displayModel.ZipFile" Label="Zip each site as a separate file" Color="Color.Tertiary" Size="Size.Medium"></MudCheckBox>

                            <MudSelect T="string" Variant="Variant.Outlined" Margin="Margin.Dense" Label="Format" Value=displayModel.ExportFormatName ValueChanged="DoValueChangedExportFormatName">
                                @foreach (var item in displayModel.ExportFormats)
                                {
                                    <MudSelectItem T="string" Value=@(item)></MudSelectItem>
                                }
                            </MudSelect>



                            <MudSelect T="string" Variant="Variant.Outlined" Margin="Margin.Dense" Label="Range" Value=displayModel.ExportPeriodName ValueChanged="DoValueChangedExportPeriodName">
                                @foreach (var item in displayModel.ExportPeriods)
                                {
                                    <MudSelectItem T="string" Value=@(item)></MudSelectItem>
                                }
                            </MudSelect>


                            <MudDateRangePicker @ref="_picker" Variant="Variant.Outlined" PickerVariant="@PickerVariant.Inline"
                                                DateRange="@displayModel.DateRange" DateRangeChanged=DoValueChangedDateRange DateFormat="dd-MMM-yy" TitleDateFormat="dd-MMM-yy"
                                                Margin="Margin.Dense" Label="Date Range" AutoClose=false ReadOnly=@(!displayModel.DateRangeEnabled)>
                                <PickerActions>



                                    <div Class="mr-auto align-self-start">

                                        <MudButton Size="Size.Small" OnClick="SetLastYear">Last Year</MudButton>
                                        <MudButton Size="Size.Small" OnClick="SetLast2Years">Last 2 Years</MudButton>
                                        <MudButton Size="Size.Small" OnClick="SetLastMonth">Last Month</MudButton>
                                    </div>

                                    <MudButton OnClick="@(() => _picker.CloseAsync(false))">Cancel</MudButton>
                                    <MudButton Color="Color.Primary" OnClick="@(() => _picker.CloseAsync())">Ok</MudButton>
                                </PickerActions>
                            </MudDateRangePicker>

                            <MudSelect Label="Interval" Variant="Variant.Outlined" Margin="Margin.Dense" Placeholder="True" T="int"
                                       value=displayModel.Interval ValueChanged="DoValueChangedInterval">
                                <MudSelectItem T="int" Value="0">Use the value stored by the meter</MudSelectItem>
                                <MudSelectItem T="int" Value="30">30 minutes</MudSelectItem>
                                <MudSelectItem T="int" Value="15">15 minutes</MudSelectItem>
                                <MudSelectItem T="int" Value="5">5 minutes</MudSelectItem>
                                <MudSelectItem T="int" Value="1">1 Minute</MudSelectItem>
                            </MudSelect>
                            <MudGrid Spacing="0">
                                <MudItem sm="12" md="6">
                                    <MudCheckBox Value=displayModel.IncludeHeader ValueChanged=DoValueChangedIncludeHeader T="bool" Size="Size.Medium" Color="Color.Tertiary" ReadOnly=@displayModel.IncludeHdrReadonly>Add Header</MudCheckBox>
                                </MudItem>
                                <MudItem sm="12" md="6">
                                    <MudCheckBox Value=displayModel.IncludeSite ValueChanged=DoValueChangedIncludeSite T="bool" Size="Size.Medium" Color="Color.Tertiary" Readonly=@displayModel.IncludeSiteReadonly>Include Site Column</MudCheckBox>
                                </MudItem>
                                <MudItem sm="12" md="6">
                                    <MudCheckBox Value=displayModel.IncludeMeter ValueChanged=DoValueChangedIncludeMeter T="bool" Size="Size.Medium" Color="Color.Tertiary" ReadOnly=@displayModel.IncludeMeterReadonly>Meter Level</MudCheckBox>
                                </MudItem>
                                <MudItem sm="12" md="6">
                                    <MudCheckBox Value=displayModel.IncludeChannel ValueChanged=DoValueChangedIncludeChannel T="bool" Size="Size.Medium" Color="Color.Tertiary" ReadOnly=@displayModel.IncludeChannelReadonly>Channel Level</MudCheckBox>
                                </MudItem>
                            </MudGrid>

                        </MudForm>
                    </MudStack>



                    <MudStack Row=true>
                        <MudButton Disabled="@DownloadButtonDisabled()" OnClick="@(async () => await DownloadFileAsync())"
                                   Variant="Variant.Filled"
                                   EndIcon="@Icons.Material.Filled.ArrowDownward"
                                   Color="Color.Info">
                            <MudStack Row=true>
                                <MudText>@(DownloadButtonText())</MudText>
                            </MudStack>
                        </MudButton>
                        @if (_ExportInProgress)
                        {
                            <MudProgressCircular Class="ms-n1  " Size="Size.Small" Indeterminate="true" />
                            <MudText>Exporting</MudText>
                        }

                    </MudStack>


                </MudPaper>


            </MudItem>

            <MudItem sm=12 md="8">
                <MudPaper Class="pa-3 ma-3" Elevation="25">
                    <MudStack Row=false>
                        <MudText Typo="Typo.h6">Preview</MudText>
                        @if (_ValidationInProgress)
                        {
                            <MudAlert Severity="Severity.Info" NoIcon=true>
                                <MudStack Row=true>
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                    <span>
                                        Validating...
                                    </span>
                                </MudStack>
                            </MudAlert>

                        }
                        else if (!_inputIsValid)
                        {
                            <MudAlert Severity="Severity.Error">
                                @if (String.IsNullOrWhiteSpace(_ErrorText))
                                {
                                    <span>
                                        Invalid input
                                    </span>
                                }
                                else
                                {
                                    <span>
                                        @(_ErrorText)
                                    </span>
                                }


                            </MudAlert>
                        }
                        else if (string.IsNullOrEmpty(_FileContents))
                        {
                            <MudAlert Severity="Severity.Info">
                                <MudStack Row=true>
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                    <span>
                                        Generating preview...
                                    </span>
                                </MudStack>
                            </MudAlert>
                        }
                        else
                        {
                            <MudAlert Severity="Severity.Success">
                                @(this._SiteDaysToExport) Days will be exported. A sample is presented for preview.
                            </MudAlert>
                            <MudPaper Style="background-color:black; color:white; height:80vh; overflow:scroll">
                                <pre>
                                    @((MarkupString)_FileContents)
                                    </pre>
                            </MudPaper>

                        }





                    </MudStack>
                </MudPaper>
            </MudItem>




        </MudGrid>




    </MudPaper>




</MudContainer>


@code {



    private Timer? _timer;
    private MudDateRangePicker _picker = default!;

    async Task SetLastYear()
    {
        _picker.DateRange.End = DateTime.Today.AddDays(-1);
        _picker.DateRange.Start = _picker.DateRange.End.Value.AddYears(-1);
        await _picker.CloseAsync();
        displayModel.DateRange = _picker.DateRange;
        await ProcessFormChanges();

    }
    async Task SetLast2Years()
    {
        _picker.DateRange.End = DateTime.Today.AddDays(-1);
        _picker.DateRange.Start = _picker.DateRange.End.Value.AddYears(-2);
        await _picker.CloseAsync();
        displayModel.DateRange = _picker.DateRange;
        await ProcessFormChanges();
    }
    async Task SetLastMonth()
    {
        _picker.DateRange.End = DateTime.Today.AddDays(-1);
        _picker.DateRange.Start = _picker.DateRange.End.Value.AddMonths(-1);
        await _picker.CloseAsync();
        displayModel.DateRange = _picker.DateRange;
        await ProcessFormChanges();
    }


    string _dataDownload = string.Empty;
    string _FileContents = "File contents will appear here";
    string _ErrorText = string.Empty;
    int _SiteDaysToExport = 0;





    /* progress */
    CancellationTokenSource? _cts = null;
    bool _ExportInProgress = false;
    bool _inputIsValid = false;
    bool _ValidationInProgress = true;




    DownloadDisplayModel displayModel = default!;

    /* Form Value Change Methods */
    async Task DoValueChangedSelectedSites(string value)
    {
        displayModel.SelectedSite = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedExportFormatName(string value)
    {
        displayModel.ExportFormatName = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedExportPeriodName(string value)
    {
        displayModel.ExportPeriodName = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedDateRange(DateRange value)
    {
        displayModel.DateRange = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedInterval(int value)
    {
        displayModel.Interval = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedIncludeHeader(bool value)
    {
        displayModel.IncludeHeader = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedIncludeSite(bool value)
    {
        displayModel.IncludeSite = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedIncludeMeter(bool value)
    {
        displayModel.IncludeMeter = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedIncludeChannel(bool value)
    {
        displayModel.IncludeChannel = value;
        await ProcessFormChanges();
    }

    async Task DoValueChangedZipFile(bool value)
    {
        displayModel.ZipFile = value;
        await ProcessFormChanges();
    }


    async Task ProcessFormChanges()
    {
        _ValidationInProgress = true;
        var cancellationToken = GetNewCancellationToken();
        if (_timer is not null)
        {
            _timer.Stop();
            _timer.Dispose();
            _timer = null;
        }

        _timer = new Timer();
        _timer.AutoReset = false;
        _timer.Interval = 100;
        _timer.Elapsed += async (sender, e) => await ProcessFormChangesWorkload(cancellationToken);
        _timer.Start();
        await Task.Yield();


    }

    async Task ProcessFormChangesWorkload(CancellationToken cancellationToken)
    {
#if DEBGUG
        Console.WriteLine($"Process Form changed.  Sites:{displayModel.SelectedSite}  DateRange:{displayModel.DateRangeString}  Period:{displayModel.ExportPeriodName} ");
#endif
        try
        {
            cancellationToken.ThrowIfCancellationRequested();
#if DEBGUG
            Console.WriteLine("validate");
#endif
            await displayModel.Validate(cancellationToken);
#if DEBGUG
            Console.WriteLine("validate Exit");
#endif


            _SiteDaysToExport = displayModel.TotalSiteDays;
            _inputIsValid = true;
            _ErrorText = string.Empty;
            _FileContents = displayModel.PreviewText;

        }
        catch (TaskCanceledException)
        { }

        catch (ArgumentException ex)
        {

            Console.WriteLine(ex);

            _ErrorText = ex.Message;
            _inputIsValid = false;
            _FileContents = _ErrorText;
            _SiteDaysToExport = 0;

        }
        catch (Exception ex)
        {
            _ErrorText = "Invalid input";
            Console.WriteLine(ex);
            _inputIsValid = false;
            _FileContents = _ErrorText;
            _SiteDaysToExport = 0;
        }
        finally
        {
            _ValidationInProgress = false;
            await InvokeAsync(StateHasChanged);
            await Task.Yield();
        }
    }


    protected override void OnInitialized()
    {
        base.OnInitialized();
        displayModel = new DownloadDisplayModel(API);
    }

    protected override async Task OnParametersSetAsync()
    {
        await ProcessFormChanges();
    }


    public bool DownloadButtonDisabled()
    {
        if (!_inputIsValid) return true;
        if (_ExportInProgress) return true;

        return false;
    }


    public string DownloadButtonText()
    {
        if (_ExportInProgress) return "Creating file...";

        return "Download";
    }

    CancellationToken GetNewCancellationToken()
    {
        if (_cts != null)
        {
            if (!_cts.IsCancellationRequested)
            {
                _cts.Cancel();
            }
            _cts.Cancel();
            _cts.Dispose();
            _cts = null;
        }
        _cts = new CancellationTokenSource();
        return _cts.Token;
    }

    void Cancel()
    {
        if (_cts != null)
        {
            if (!_cts.IsCancellationRequested)
            {
                _cts.Cancel();
            }
            _cts.Cancel();
            _cts.Dispose();
            _cts = null;
        }
    }


    public void Dispose()
    {

        Cancel();
    }


    public async Task DownloadFileAsync()
    {
        try
        {

            _ExportInProgress = true;
            var token = GetNewCancellationToken();
            var fileStream = await displayModel.GetFileContentsAsync(token);
            _FileContents = displayModel.PreviewText;
            _inputIsValid = true;
            // download the stream to a file
            using var streamRef = new DotNetStreamReference(stream: fileStream);
            token.ThrowIfCancellationRequested();
            string filename = displayModel.Filename();
            #if DEBUG
            Console.WriteLine($"DEBUG: {DateTime.Now:HH:mm:ss.fff}  downloadFile - call javaScript with filename {filename} ");
            #endif
            token.ThrowIfCancellationRequested();
            await JSRuntime.InvokeVoidAsync("downloadFileFromStream", filename, streamRef);


        }
        catch (TaskCanceledException)
        {
            Console.WriteLine("DEBUG: DownloadFileAsync Cancelled");
            _ErrorText = "Download Cancelled";
            _inputIsValid = false;
        }
        catch (Exception ex)
        {
            Console.WriteLine("DEBUG: DownloadFileAsync Exception");
            Console.WriteLine(ex);
            _ErrorText = "Error creating file";
            _inputIsValid = false;
            _FileContents = string.Empty;
        }
        finally
        {
            _ExportInProgress = false;
            _ValidationInProgress = false;

        }


    }



    class DownloadDisplayModel
    {
        private readonly MeterKloudClientApi _api;
        private readonly Dictionary<string, Site> _sites;
        static readonly Dictionary<string, ExportFormat> exportFormatNames = new Dictionary<string, ExportFormat> { { "NEM12", ExportFormat.NEM12 }, { "Quadrant CSV", ExportFormat.QuadrantCSV }, { "Columnar CSV", ExportFormat.ColumnarCSV }, { "Row CSV", ExportFormat.RowCSV } };




        bool _IncludeHdrReadonly = true;
        bool _IncludeSiteReadonly = true;
        bool _IncludeMeterReadonly = true;
        bool _IncludeChannelReadonly = true;

        public enum ExportPeriod
        {
            LastYearOfSiteData,
            Last2YearsOfSiteData,
            Last6MonthsOfSiteData,
            Last3MonthsOfSiteData,
            LastMonthOfSiteData,
            Last12CalendarMonths,
            Last6CalendarMonths,
            Last3CalendarMonths,
            LastMonth,
            CustomDateRange
        }
        static readonly Dictionary<string, ExportPeriod> exportPeriodNames = new Dictionary<string, ExportPeriod> { { "Last year of Site Data", ExportPeriod.LastYearOfSiteData }, { "Last 2 years of Site Data", ExportPeriod.Last2YearsOfSiteData }, { "Last 6 months of Site Data", ExportPeriod.Last6MonthsOfSiteData }, { "Last 3 months of Site Data", ExportPeriod.Last3MonthsOfSiteData }, { "Last month of Site Data", ExportPeriod.LastMonthOfSiteData }, { "Last 12 calendar months", ExportPeriod.Last12CalendarMonths }, { "Last 6 calendar months", ExportPeriod.Last6CalendarMonths }, { "Last 3 calendar months", ExportPeriod.Last3CalendarMonths }, { "Last month", ExportPeriod.LastMonth }, { "Custom Date Range", ExportPeriod.CustomDateRange } };



        public DownloadDisplayModel(MeterKloudClientApi api)
        {
            _api = api;
            var list = (_api.GetSites()).GetAwaiter().GetResult();
            if (list.Any())
            {
                //create dictionary of sites
                _sites = list.ToDictionary(site => site.Code.ToUpperInvariant(), site => site);
            }
            else
            {
                _sites = new Dictionary<string, Site>();
            }

            // get the last site accessed
            var lastSite = (_api.GetLastSiteAccessed()).GetAwaiter().GetResult();
            if (lastSite != null)
            {
                if (_sites.ContainsKey(lastSite.Code))
                {
                    SelectedSite = lastSite.Code.ToUpperInvariant();
                }
            }
            this.ExportFormatName = exportFormatNames.First().Key;


        }

        public bool MultiSiteEnabled => _sites.Count > 1;
        public bool MultiSiteDisabled => !MultiSiteEnabled;
        private bool _multiSite = false;

        public bool MultiSite
        {
            get
            {
                if (!MultiSiteEnabled)
                {
                    return false;
                }
                return _multiSite;
            }
            set
            {
                _multiSite = value;
                if (!_multiSite && SelectedSite.IndexOf(',') >= 0)
                {
                    SelectedSite = FirstSite().Code;

                }




            }
        }

        public IEnumerable<string> SiteNames => _sites.Keys;



        public Site FirstSite()
        {
            var firstSite = SelectedSiteList().FirstOrDefault() ?? new Site(); ;

            return firstSite;
        }


        private string _selectedSite = string.Empty;
        public string SelectedSite
        {
            get { return _selectedSite; }
            set
            {
                _selectedSite = value;
                SetDateRange();
                _RecalculateDays = true;
            }
        }






        public List<Site> SelectedSiteList()
        {
            if (string.IsNullOrWhiteSpace(SelectedSite))
            {
                return new List<Site>();
            }
            var stringList = _selectedSite.ToUpperInvariant().Split(',', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries).Distinct();
            return stringList.Where(xxxx => _sites.ContainsKey(xxxx)).Select(siteCode => _sites[siteCode]).ToList();
        }



        private bool _zipFile = true;

        public bool ZipFileEnabled => MultiSite && SelectedSiteList().Count > 1;

        public bool ZipFile
        {
            get
            {
                if (!ZipFileEnabled)
                {
                    return false;
                }
                return _zipFile;

            }
            set { _zipFile = value; }
        }



        public List<string> ExportFormats => exportFormatNames.Keys.ToList();
        private ExportFormat _exportFormat = MeterDataLib.Export.ExportFormat.NEM12;
        public string ExportFormatName
        {
            get
            {
                var item = exportFormatNames.FirstOrDefault(xxx => xxx.Value == _exportFormat);
                if (item.Equals(default(KeyValuePair<string, ExportFormat>)))
                {
                    return exportFormatNames.First().Key;
                }
                return item.Key;

            }
            set
            {
                // validate the value
                if (exportFormatNames.ContainsKey(value))
                {
                    _exportFormat = exportFormatNames[value];
                    SetOptionsFromFormat();
                }
            }
        }



        public List<string> ExportPeriods => exportPeriodNames.Keys.ToList();
        private ExportPeriod _exportPeriod = ExportPeriod.LastYearOfSiteData;
        public string ExportPeriodName
        {
            get
            {
                var item = exportPeriodNames.FirstOrDefault(xxx => xxx.Value == _exportPeriod);
                if (item.Equals(default(KeyValuePair<string, ExportPeriod>)))
                {
                    return exportPeriodNames.First().Key;
                }
                return item.Key;

            }
            set
            {
                // validate the value
                if (exportPeriodNames.ContainsKey(value))
                {
                    _exportPeriod = exportPeriodNames[value];
                    SetDateRange();
                }
            }
        }

        public bool DateRangeEnabled => _exportPeriod == ExportPeriod.CustomDateRange;

        private void SetDateRange()
        {

            _RecalculateDays = true;
            DateTime lastLastDay = SelectedSiteList().Any() ? SelectedSiteList().Max(site => site.LastDay) : DateTime.Today.AddDays(-1);
            DateTime firstLastDay = SelectedSiteList().Any() ? SelectedSiteList().Min(site => site.LastDay) : DateTime.Today.AddDays(-1);
            switch (_exportPeriod)
            {
                case ExportPeriod.LastYearOfSiteData:
                    DateRange = new DateRange(firstLastDay.AddYears(-1), lastLastDay);
                    break;
                case ExportPeriod.Last2YearsOfSiteData:
                    DateRange = new DateRange(firstLastDay.AddYears(-2), lastLastDay);
                    break;
                case ExportPeriod.Last6MonthsOfSiteData:
                    DateRange = new DateRange(firstLastDay.AddMonths(-6), lastLastDay);
                    break;
                case ExportPeriod.Last3MonthsOfSiteData:
                    DateRange = new DateRange(firstLastDay.AddMonths(-3), lastLastDay);
                    break;
                case ExportPeriod.LastMonthOfSiteData:
                    DateRange = new DateRange(firstLastDay.AddMonths(-1), lastLastDay);
                    break;
                case ExportPeriod.Last12CalendarMonths:
                    DateRange = new DateRange(DateTime.Today.AddMonths(-12), DateTime.Today.AddDays(-1));
                    break;
                case ExportPeriod.Last6CalendarMonths:
                    DateRange = new DateRange(DateTime.Today.AddMonths(-6), DateTime.Today.AddDays(-1));
                    break;
                case ExportPeriod.Last3CalendarMonths:
                    DateRange = new DateRange(DateTime.Today.AddMonths(-3), DateTime.Today.AddDays(-1));
                    break;
                case ExportPeriod.LastMonth:
                    DateRange = new DateRange(DateTime.Today.AddMonths(-1), DateTime.Today.AddDays(-1));
                    break;
                case ExportPeriod.CustomDateRange:

                    break;
            }
        }


        private DateRange _dateRange = new DateRange(DateTime.Today.AddYears(-1), DateTime.Today.AddDays(-1));
        public DateRange DateRange
        {
            get { return _dateRange; }
            set { _dateRange = value; _RecalculateDays = true; }
        }

        public DateTime FromDate => DateRange.Start ?? DateTime.Today.AddYears(-1);
        public DateTime ToDate => DateRange.End ?? DateTime.Today.AddDays(-1);


        public string DateRangeString => $"[{DateRange.Start:dd-MMM-yy} to {DateRange.End:dd-MMM-yy}]";



        private int _interval = 0;
        public int Interval
        {
            get { return _interval; }
            set { _interval = value; }
        }


        public bool IncludeHdrReadonly => _IncludeHdrReadonly;
        public bool IncludeSiteReadonly => _IncludeSiteReadonly;
        public bool IncludeMeterReadonly => _IncludeMeterReadonly;
        public bool IncludeChannelReadonly => _IncludeChannelReadonly;

        private bool _includeHeader = true;
        public bool IncludeHeader
        {
            get { return _includeHeader; }
            set { if (IncludeHdrReadonly) return; _includeHeader = value; }
        }

        private bool _includeSite = true;
        public bool IncludeSite
        {
            get { return _includeSite; }
            set { if (IncludeSiteReadonly) return; _includeSite = value; }
        }

        private bool _includeChannel = true;
        public bool IncludeChannel
        {
            get { return _includeChannel; }
            set { if (IncludeChannelReadonly) return; _includeChannel = value; }
        }

        private bool _includeMeter = true;
        public bool IncludeMeter
        {
            get { return _includeMeter; }
            set { if (IncludeMeterReadonly) return; _includeMeter = value; }
        }


        void SetOptionsFromFormat()
        {
            switch (_exportFormat)
            {
                case ExportFormat.NEM12:
                    _includeHeader = true;
                    _IncludeHdrReadonly = false;

                    _IncludeSiteReadonly = true;
                    _includeSite = true;

                    _includeChannel = true;
                    _IncludeChannelReadonly = true;

                    _includeMeter = true;
                    _IncludeMeterReadonly = true;

                    break;
                case ExportFormat.QuadrantCSV:

                    _includeHeader = true;
                    _IncludeHdrReadonly = false;

                    _includeSite = false;
                    _IncludeSiteReadonly = false;

                    _includeChannel = true;
                    _IncludeChannelReadonly = true;

                    _includeMeter = false;
                    _IncludeMeterReadonly = false;


                    break;
                case ExportFormat.ColumnarCSV:
                    _includeHeader = true;
                    _IncludeHdrReadonly = false;

                    _includeSite = false;
                    _IncludeSiteReadonly = false;

                    _includeChannel = true;
                    _IncludeChannelReadonly = true;

                    _includeMeter = false;
                    _IncludeMeterReadonly = false;



                    break;
                case ExportFormat.RowCSV:
                    _includeHeader = true;
                    _IncludeHdrReadonly = false;

                    _includeSite = false;
                    _IncludeSiteReadonly = false;

                    _includeChannel = true;
                    _IncludeChannelReadonly = true;

                    _includeMeter = false;
                    _IncludeMeterReadonly = false;
                    break;

            }
        }

        public override string ToString()
        {
            return $"Model: Sites={SelectedSite}  Period={ExportPeriodName}  Format={ExportFormatName}  DateRange={DateRangeString}  Interval={Interval}  IncludeHeader={IncludeHeader}  IncludeSite={IncludeSite}  IncludeMeter={IncludeMeter}  IncludeChannel={IncludeChannel}";
        }

        public int SiteCount()
        {
            return SelectedSiteList().Count;
        }




        bool _RecalculateDays = true;
        List<SiteDay> _days = new List<SiteDay>();
        public int TotalSiteDays => _days.Count();
        string _previewText = string.Empty;
        public string PreviewText => _previewText;
        ExportOptions? _ExportOptions = null;
        ExportOptions? ExportOptions => _ExportOptions;




        public async Task Validate(CancellationToken cancellationToken)
        {

            if (string.IsNullOrWhiteSpace(SelectedSite))
            {

                throw new ArgumentException("No selected sites");
            }
            if (DateRange.Start.HasValue && DateRange.End.HasValue)
            {
                if (DateRange.Start.Value > DateRange.End.Value)
                {
                    throw new ArgumentException("Invalid date range");
                }
            }
            var days = await GetSiteDays(cancellationToken);

            if (days.Count == 0)
            {
                throw new ArgumentException("No site days available to export");
            }

            if (days.Count > ExportData.MaxDays)
            {
                throw new ArgumentException($"Days to export is {days.Count} which exceeds th max allowed number of {ExportData.MaxDays} ");
            }
            _previewText = await GetPreviewStringAsync(cancellationToken);
            return;

        }


        public string Filename()
        {
            // return the name of the file to be downloaded
            if (ZipFile)
            {
                return $"MultiSiteExport_{FromDate:yyyyMMdd}_{ToDate:yyyyMMdd}_{_exportFormat}.zip";
            }
            else if (SiteCount() == 1)
            {
                return $"{SelectedSite}_{FromDate:yyyyMMdd}_{ToDate:yyyyMMdd}_{_exportFormat}.csv";
            }
            else
            {
                return $"MultiSiteExport_{FromDate:yyyyMMdd}_{ToDate:yyyyMMdd}_{_exportFormat}.csv";
            }
        }


        async Task<List<SiteDay>> GetSiteDays(CancellationToken? cancellationToken)
        {
            //Console.WriteLine($"DEBUG: Get Site Days  ReCalc={_RecalculateDays}");
            //Console.WriteLine(this.ToString());

            if (_RecalculateDays)
            {

                var timer = System.Diagnostics.Stopwatch.StartNew();
                await ObtainSiteDays(cancellationToken);
                var elapsed = timer.ElapsedMilliseconds;
                //Console.WriteLine($"DEBUG: Get Site Days completed  days={_days.Count}  Elapsed={elapsed} ms");

            }
            return _days;
        }


        async Task ObtainSiteDays(CancellationToken? cancellationToken)
        {
            cancellationToken?.ThrowIfCancellationRequested();
            List<SiteDay> result = [];
            var list = SelectedSiteList().Distinct();
            int totalSites = list.Count();
            int siteNumber = 0;
            foreach (var site in list)
            {
                ++siteNumber;
                cancellationToken?.ThrowIfCancellationRequested();
                DateTime toDate = DateTime.Today.AddDays(-1);
                DateTime fromDate = DateTime.Today.AddDays(-1).AddYears(-1);

                switch (this._exportPeriod)
                {
                    case ExportPeriod.Last6CalendarMonths:
                        fromDate = toDate.AddMonths(-6);
                        break;
                    case ExportPeriod.Last3CalendarMonths:
                        fromDate = toDate.AddMonths(-3);
                        break;
                    case ExportPeriod.LastMonth:
                        fromDate = toDate.AddMonths(-1);
                        break;
                    case ExportPeriod.LastYearOfSiteData:
                        toDate = site.LastDay;
                        fromDate = toDate.AddYears(-1);
                        break;
                    case ExportPeriod.Last2YearsOfSiteData:
                        toDate = site.LastDay;
                        fromDate = toDate.AddYears(-2);
                        break;
                    case ExportPeriod.Last6MonthsOfSiteData:
                        toDate = site.LastDay;
                        fromDate = toDate.AddMonths(-6);
                        break;
                    case ExportPeriod.Last3MonthsOfSiteData:
                        toDate = site.LastDay;
                        fromDate = toDate.AddMonths(-3);
                        break;
                    case ExportPeriod.LastMonthOfSiteData:
                        toDate = site.LastDay;
                        fromDate = toDate.AddMonths(-1);
                        break;
                    case ExportPeriod.Last12CalendarMonths:
                        fromDate = toDate.AddMonths(-12);
                        break;
                    case ExportPeriod.CustomDateRange:
                        // Custom date range logic here
                        if (DateRange.Start.HasValue)
                        {
                            fromDate = DateRange.Start.Value;
                        }
                        if (DateRange.End.HasValue)
                        {
                            toDate = DateRange.End.Value;
                        }
                        break;
                }


#if DEBGUG
                    Console.WriteLine($"DEBUG: Get Site Days  Site Number {siteNumber}/{totalSites} Site={site.Code}  From={fromDate}  To={toDate}");
#endif
                cancellationToken?.ThrowIfCancellationRequested();
                var siteDays = await _api.GetSiteDays(site.Id, fromDate, toDate);
                // add the site days to the list
                int prevCount = result.Count;
                result.AddRange(siteDays);
#if DEBGUG
                Console.WriteLine($"DEBUG: Get Site Days  Site Number {siteNumber}/{totalSites}  Site={site.Code}  Days={siteDays.Count}  Total={result.Count}  Prev={prevCount}");
#endif

            }
            _RecalculateDays = false;
            _days = result;
#if DEBGUG
            Console.WriteLine($"DEBUG: Exit Get Site Days  Site Number {totalSites}    Days={_days.Count}  ");
#endif
        }


        async Task<String> GetPreviewStringAsync(CancellationToken? ct = null)
        {

            var days = _days;
            var code = days.First().SiteCode;
            var first10 = days.Where(Site => Site.SiteCode == code).Take(10);
            var options = new ExportOptions()
                {
                    IncludeHeader = IncludeHeader,
                    IncludeSite = IncludeSite,
                    IncludeMeter = IncludeMeter,
                    IncludeChannel = IncludeChannel,
                    IntervalInMinutes = Interval,
                    ExportType = _exportFormat,
                    SiteDays = first10,
                };
            var result = await _api.Export(options, ct);
            return result;
        }




        async Task<int> SiteDayCount(CancellationToken? cancellationToken = null)
        {
            return (await GetSiteDays(cancellationToken)).Count;
        }






        public async Task<Stream> GetFileContentsAsync(CancellationToken ct)
        {
            ct.ThrowIfCancellationRequested();
            await Validate(ct);
            await Task.Yield();
            ct.ThrowIfCancellationRequested();

            var options = new ExportOptions()
                {
                    IncludeHeader = IncludeHeader,
                    IncludeSite = IncludeSite,
                    IncludeMeter = IncludeMeter,
                    IncludeChannel = IncludeChannel,
                    IntervalInMinutes = Interval,
                    ExportType = _exportFormat,
                    SiteDays = (await GetSiteDays(ct))
                };
            ct.ThrowIfCancellationRequested();
            if (ZipFile)
            {
                return await _api.ExportMultiFile(options, ct);
            }
            else
            {
                var txt = await _api.Export(options, ct);
                return new MemoryStream(System.Text.Encoding.UTF8.GetBytes(txt));
            }
        }



    }





}
